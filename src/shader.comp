#version 450
struct Particle
{
	vec2 pos;
	vec2 vel;
};

// LOOK: These bindings correspond to the DescriptorSetLayouts and
// the DescriptorSets from prepareCompute()!

// Binding 0 : Particle storage buffer (read)
layout(set = 0, binding = 1) buffer ParticlesA
{
   Particle particlesA[ ];
};
int NUM_PARTICLES = 1500;
// Binding 1 : Particle storage buffer (write)
layout(set = 0, binding = 2) buffer ParticlesB
{
   Particle particlesB[ ];
};
// this value is set in the outside also, so that the actual number of work groups * our local size is equal to number particles

layout (local_size_x = 64, local_size_y = 1) in; // LOOK: rule weights and distances, as well as particle count, based off uniforms.// The deltaT here has to be updated every frame to account for changes in

// frame rate.
layout (set = 0 ,binding = 0) uniform UBO
{
	float deltaT;
	float rule1Distance;
	float rule2Distance;
	float rule3Distance;
	float rule1Scale;
	float rule2Scale;
	float rule3Scale;
} ubo;

void main()
{
		// LOOK: This is very similar to a CUDA kernel.
		// Right now, the compute shader only advects the particles with their
		// velocity and handles wrap-around.
		// TODO: implement flocking behavior.

    // Current SSBO index
    uint index = gl_GlobalInvocationID.x;
	float computable_index = float(index);
	// I guess this is going to be the same as the gl_LocalInvocationIndex this time because its a one dimensional compute anyways,
	// set the constants
	// these are the size of our grid
	float width = 256;
	float height =  256;
	// then the space between the parts
	float space = 5;
	// points to place along width and height
	float w_points = width/space;
	float h_points = height/space;
	// then using mod and floor we can associate a particle invocation index with these w-hpoints
	float xpos = mod(computable_index,w_points)*space;
	float ypos = floor(computable_index/h_points)*space;
    particlesB[index].pos.xy = vec2(xpos/width*2 - 1,ypos/height *2 - 1);
}